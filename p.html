<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - materials</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #202020;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/jquery.min.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/glMatrix.min.js"></script>
		<script>
			var loader, base, trunk, arm1, arm2, hammer;
			var container, stats;
			var camera, scene, renderer, objects;
			var particleLight, pointLight;
			var modelInitialized=false;
	

			////
			init();
			animate();
	
			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.0000001, 2000 );
				width=window.innerWidth;
				height=window.innerHeight;
				o_width=width;
				o_height=height;
				//camera.position.set( 0, 200, 800 );
				{
					camera.position.set( 0, 1, 1 );
					controls = new THREE.OrbitControls( camera );
					controls.addEventListener( 'change', render );
					window.addEventListener( 'resize', onWindowResize, false );
					//controls.userRotate=1;
				}

				scene = new THREE.Scene();

				// Grid
				{
					var size = 1, step = 0.2;
					var geometry = new THREE.Geometry();
					for ( var i = - size; i <= size; i += step ) {
						geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
						geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
					}
					var material = new THREE.LineBasicMaterial( { color: 0xffffff, opacity: 1, linewidth:5 } );
					var line = new THREE.Line( geometry, material );
					line.type = THREE.LinePieces;
					scene.add( line );
				}

				//model
				{
					scale=0.04;
					//var m=new THREE.Matrix4();
					//m.scale(scale);
					var m=new THREE.Matrix4();
					m.makeScale(scale,scale,scale);
					loader = new THREE.JSONLoader();
					loader.load( 'obj/robot/base.js', function ( geometry ) {
						base = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						base.applyMatrix(m);
					} );
					loader.load( 'obj/robot/trunk.js', function ( geometry ) {
						trunk = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						trunk.pivot=new THREE.Vector3(0,0,0);
						trunk.axis=new THREE.Vector3(0,1,0);
						trunk.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm1.js', function ( geometry ) {
						arm1 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm1.pivot=new THREE.Vector3(-0.13,0.176,0);
						arm1.axis=new THREE.Vector3(0,0,-1);
						arm1.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm2.js', function ( geometry ) {
						arm2 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm2.pivot=new THREE.Vector3(-0.530,0.176,0);
						arm2.axis=new THREE.Vector3(0,0,-1);
						arm2.applyMatrix(m);
					} );
					loader.load( 'obj/robot/hammer.js', function ( geometry ) {
						hammer = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						hammer.pivot=new THREE.Vector3(-0.915,0.176,0);
						hammer.axis=new THREE.Vector3(0,0,1);
						hammer.applyMatrix(m);
					} );
				}

				// Lights
				{
					particleLight = new THREE.Particle( new THREE.ParticleBasicMaterial( { color: 0xffffff  } ) );
					particleLight.scale.x = particleLight.scale.y = particleLight.scale.z = 4;
					scene.add( particleLight );
					pointLight = new THREE.PointLight( 0xffffff, 1 );
					scene.add( pointLight );
				}

				//rederer
				{
					renderer = new THREE.CanvasRenderer();
					renderer.setSize( o_width, o_height);
					container.appendChild( renderer.domElement );
				}

				//canvas
				{
					var debugCanvas = document.createElement( 'canvas' );
					debugCanvas.width = 512;
					debugCanvas.height = 512;
					debugCanvas.style.position = 'absolute';
					debugCanvas.style.top = '0px';
					debugCanvas.style.left = '0px';

					container.appendChild( debugCanvas );

					debugContext = debugCanvas.getContext( '2d' );
					debugContext.setTransform( 1, 0, 0, 1, 256, 256 );
					debugContext.strokeStyle = '#000000';
				}

				//stats
				{
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					container.appendChild(stats.domElement);
				}

			}
			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
				controls.update();
			}
			var hammerG,arm2G,arm1G,trunkG,baseG;
			var somem=new THREE.Matrix4();
			var arm1Step=1;
			var trunkStep=1;
			var arm2Step=1;
			somem.makeScale(0.1,0.1,0.1);
			function render() {
				if(!modelInitialized){
					if(base && trunk && arm1 && arm2 && hammer){
						hammerG=new THREE.Object3D();
						arm2G=new THREE.Object3D();
						arm1G=new THREE.Object3D();
						trunkG=new THREE.Object3D();
						baseG=new THREE.Object3D();
						hammerG.angle=0;
						arm2G.angle=0;
						arm1G.angle=0;
						trunkG.angle=0;


						hammerG.add(hammer);
						arm2G.add(hammerG);
						arm2G.add(arm2);
						arm1G.add(arm2G);
						arm1G.add(arm1);
						trunkG.add(arm1G);
						trunkG.add(trunk);
						baseG.add(trunkG);
						baseG.add(base);
						scene.add(baseG);

						modelInitialized=true;
					}
					else return;
				}
				scene.position.x=0
				scene.position.y=0
				scene.position.z=0
				camera.lookAt( scene.position );

				particleLight.position.x = 0
				particleLight.position.y = 300 
				particleLight.position.z = 0
				pointLight.position.x = particleLight.position.x;
				pointLight.position.y = particleLight.position.y;
				pointLight.position.z = particleLight.position.z;

				if(arm1Step>0 && arm1G.angle+arm1Step>90){
					arm1Step=-arm1Step;
				}
				else if(arm1Step<0 && arm1Step+arm1G.angle<0){
					arm1Step=-arm1Step;
				}
				if(arm2Step>0 && arm2G.angle+arm2Step>0){
					arm2Step=-arm2Step;
				}
				else if(arm2Step<0 && arm2Step+arm2G.angle<-120){
					arm2Step=-arm2Step;
				}

				rotateArm1(arm1G.angle+arm1Step);
				rotateArm2(arm2G.angle+arm2Step);
				rotateTrunk(trunkG.angle+trunkStep);
				balanceHammer();
				renderer.render( scene, camera );
			}
			function rotateTrunk(angle){
				trunkG.angle=angle;
				var angle=trunkG.angle/180*Math.PI;
				trunkG.matrix.identity();
				var m=new THREE.Matrix4();
				m.rotateByAxis(trunk.axis, angle);
				trunkG.applyMatrix(m);
			}
			function rotateArm1(angle){
				arm1G.angle=angle;
				angle=arm1G.angle/180*Math.PI;
				arm1G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm1.pivot);
				m.rotateByAxis(arm1.axis, angle);
				m.translate(new THREE.Vector3(-1*arm1.pivot.x, -1*arm1.pivot.y,-1*arm1.pivot.z));
				arm1G.applyMatrix(m);
			}
			function rotateArm2(angle){
				arm2G.angle=angle;
				console.log(arm2G.angle)
				angle=arm2G.angle/180*Math.PI;
				arm2G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm2.pivot);
				m.rotateByAxis(arm2.axis, angle);
				m.translate(new THREE.Vector3(-1*arm2.pivot.x, -1*arm2.pivot.y,-1*arm2.pivot.z));
				arm2G.applyMatrix(m);
			}
			function rotateHammer(angle){
				hammerG.angle=angle;
				console.log(hammerG.angle)
				angle=hammerG.angle/180*Math.PI;
				hammerG.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(hammer.pivot);
				m.rotateByAxis(hammer.axis, angle);
				m.translate(new THREE.Vector3(-1*hammer.pivot.x, -1*hammer.pivot.y,-1*hammer.pivot.z));
				hammerG.applyMatrix(m);
			}
			function balanceHammer(){
				rotateHammer(arm1G.angle+arm2G.angle);
			}

		</script>
	</body>
</html>
