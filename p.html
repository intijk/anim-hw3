<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - materials</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #e2d8ce;
				margin: 0px;
				overflow: hidden;
			}
			.btn{
				position:absolute;
				top:200px;
				left:800px;
				width:200px;
				padding:0px;
				margin:0px;
				background-color:#e2d8ce;
			}
			.btnImg{
				padding:0px;
				margin:0px;
			}


		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/jquery.min.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/glMatrix.min.js"></script>
		<script src="js/curve.js"></script>
		<button class="btn" type="button" id="clear" onclick="clearPathCurvePoints()"/>
			<img class="btnImg" src="image/clear.png" id="clearImg"></img>
		</button>

		<button class="btn" type="button" id="delete" onclick="deletePathCurvePoints()"/>
			<img class="btnImg" src="image/delete.png" id="deleteImg"></img>
		</button>

		<button class="btn" type="button" id="playOrPause" onclick="playOrPause()"/>
			<img class="btnImg" src="image/play.png" id="playPauseImg"></img>
		</button>

		<button class="btn" type="button" id="stop" onclick="stop()"/>
			<img class="btnImg" src="image/stop.png" id="stopImg"></img>
		</button>

		<button class="btn" type="button" id="view1" onclick="setView(1)"/>
			<img class="btnImg" src="image/view1.png" id="view1Img"></img>
		</button>

		<button class="btn" type="button" id="view2" onclick="setView(2)"/>
			<img class="btnImg" src="image/view2.png" id="view2Img"></img>
		</button>

		<button class="btn" type="button" id="view3" onclick="setView(3)"/>
			<img class="btnImg" src="image/view3.png" id="view3Img"></img>
		</button>

		<button class="btn" type="button" id="view4" onclick="setView(4)"/>
			<img class="btnImg" src="image/view4.png" id="view4Img"></img>
		</button>

		<button class="btn" type="button" id="view5" onclick="setView(5)"/>
			<img class="btnImg" src="image/view5.png" id="view5Img"></img>
		</button>

		<button class="btn" type="button" id="view6" onclick="setView(6)"/>
			<img class="btnImg" src="image/view6.png" id="view6Img"></img>
		</button> 

		<script>
			var loader, base, trunk, arm1, arm2, hammer;
			var container, stats;
			var camera, scene, renderer, objects;
			var particleLight, pointLight;
			var modelInitialized=false;
			var projector=new THREE.Projector();
			var pathCurve=new Curve();
			var controls;
			var panelCurve=new Curve();
			var panelR,panelScene,panelCamera,panelWidth,panelHeight;
			

			init();
			animate();
	
			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				o_width=window.innerWidth*0.618;
				o_height=window.innerHeight;
				{
					camera = new THREE.PerspectiveCamera( 45, o_width / o_height, 0.025, 2000 );
					//camera = new THREE.OrthographicCamera(-1,1,1,-1);
					setView(1);
					controls = new THREE.OrbitControls( camera );
					controls.addEventListener( 'change', render );
					window.addEventListener( 'resize', onWindowResize, false );
					//controls.userRotate=1;
				}

				scene = new THREE.Scene();

				// Grid
				{
					var size = 1, step = 0.2;
					var geometry = new THREE.Geometry();
					for ( var i = - size; i <= size; i += step ) {
						geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
						geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
					}
					var material = new THREE.LineBasicMaterial( { color: 0xb3aca4, opacity: 1, linewidth:1 } );
					var line = new THREE.Line( geometry, material );
					line.type = THREE.LinePieces;
					scene.add( line );
				}

				//model
				{
					scale=0.04;
					//var m=new THREE.Matrix4();
					//m.scale(scale);
					var m=new THREE.Matrix4();
					m.makeScale(scale,scale,scale);
					loader = new THREE.JSONLoader();
					loader.load( 'obj/robot/base.js', function ( geometry ) {
						base = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true  } ) );
						base.applyMatrix(m);
					} );
					loader.load( 'obj/robot/trunk.js', function ( geometry ) {
						trunk = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						trunk.pivot=new THREE.Vector3(0,0,0);
						trunk.axis=new THREE.Vector3(0,1,0);
						trunk.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm1.js', function ( geometry ) {
						arm1 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm1.pivot=new THREE.Vector3(-0.13,0.176,0);
						arm1.axis=new THREE.Vector3(0,0,-1);
						arm1.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm2.js', function ( geometry ) {
						arm2 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm2.pivot=new THREE.Vector3(-0.530,0.176,0);
						arm2.axis=new THREE.Vector3(0,0,-1);
						arm2.applyMatrix(m);
					} );
					loader.load( 'obj/robot/hammer.js', function ( geometry ) {
						hammer = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw:true } ) );

						hammer.pivot=new THREE.Vector3(-0.915,0.176,0);
						hammer.axis=new THREE.Vector3(0,0,1);
						hammer.applyMatrix(m);
					} );
				}


				//renderer
				{
					//renderer = new THREE.CanvasRenderer();
					renderer = new THREE.WebGLRenderer();
					renderer.setSize( o_width, o_height);

					renderer.domElement.style.position = 'absolute';
					renderer.domElement.style.top= '0px';
					renderer.domElement.style.left = '0px';
					renderer.domElement.style.backgroundColor="#e8dfd6";
					container.appendChild( renderer.domElement );

				}
				//panel
				{
					panelR=new THREE.CanvasRenderer();
					panelR = new THREE.WebGLRenderer();
					//background
					panelR.domElement.style.backgroundColor="#e8dfd6";


					//curve initial points
					panelCurve.points.push(new THREE.Vector2(0,0));
					panelCurve.points.push(new THREE.Vector2(0.3333,0.3333));
					panelCurve.points.push(new THREE.Vector2(0.6666,0.6666));
					panelCurve.points.push(new THREE.Vector2(1,1));


					//panelScene	
					panelScene=new THREE.Scene();		
					//panelCamera
					panelCamera = new THREE.OrthographicCamera(-1,1,o_width/o_height,-1*o_width/o_height);
					panelCamera.position.set(0,2,0);
					panelCamera.lookAt(new THREE.Vector3(0,0,0));
					panelCamera.updateProjectionMatrix();
					resizePanel();

					//add
					container.appendChild(panelR.domElement );

				}
				
				//panel coordinates
				{

					var geometry = new THREE.Geometry();
					geometry.vertices.push(new THREE.Vector3(-0.1,0,0));
					geometry.vertices.push(new THREE.Vector3(1.1,0,0));
					geometry.vertices.push(new THREE.Vector3(0,0,-0.1));
					geometry.vertices.push(new THREE.Vector3(0,0,1.1));
					var material = new THREE.LineBasicMaterial( { color: 0xb3aca4, opacity: 1, linewidth:3 } );
					var line = new THREE.Line( geometry, material );
					line.type=THREE.LinePieces;
					panelScene.add( line );

					var sphere=new THREE.Mesh(new THREE.SphereGeometry(0.03, 24, 24 ),new THREE.MeshBasicMaterial( { color: 0xe32429,overdraw:true } ));
					sphere.position.x=0
					sphere.position.y=0;
					sphere.position.z=0;
					panelScene.add(sphere);
				}

				//stats
				{
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					container.appendChild(stats.domElement);
				}

				//buttons
				resizeButtons();					
			}
			function resizeButtons(){
				var bWidth=(1-0.618)*window.innerWidth/6;
				var bHeight=bWidth;
				var imgWidth=bWidth-4;
				var imgHeight=imgWidth;
				$('.btn').css("width",bWidth);
				$('.btn').css("height",bHeight);
				$('.btnImg').css("width",imgWidth);
				$('.btnImg').css("height",imgHeight);
				var topB=o_height*(1-0.618);
				var leftB=o_width;

				$('#clear').css("top",topB+bHeight);
				$('#clear').css("left",leftB);

				$('#delete').css("top",topB+bHeight);
				$('#delete').css("left",leftB+bWidth*1);

				$('#playOrPause').css("top",topB+bHeight);
				$('#playOrPause').css("left",leftB+bWidth*2);

				$('#stop').css("top",topB+bHeight);
				$('#stop').css("left",leftB+bWidth*3);
				//views
				$('#view1').css("top",topB);
				$('#view1').css("left",leftB+bWidth*0);

				$('#view2').css("top",topB);
				$('#view2').css("left",leftB+bWidth*1);

				$('#view3').css("top",topB);
				$('#view3').css("left",leftB+bWidth*2);

				$('#view4').css("top",topB);
				$('#view4').css("left",leftB+bWidth*3);

				$('#view5').css("top",topB);
				$('#view5').css("left",leftB+bWidth*4);

				$('#view6').css("top",topB);
				$('#view6').css("left",leftB+bWidth*5);

		
			}
			function clearPathCurvePoints(){
				pathCurve.points=[];
				pathCurve.draw(scene);
			}
			function deletePathCurvePoints(){
				if(pathCurve.deleteStatus==undefined || pathCurve.deleteStatus==0){
					pathCurve.deleteStatus=1;
					$('#deleteImg').attr("src", "image/deleteShadow.png");
				}else{
					pathCurve.deleteStatus=1-pathCurve.deleteStatus;
					$('#deleteImg').attr("src", "image/delete.png");
				}
			}
			function playOrPause(){
			}

			function setView(n){
				if(n==1){
					camera.position.set(-2,2,2);
					camera.updateProjectionMatrix();
				}else if(n==2){
					camera.position.set(0,4,0);
					camera.updateProjectionMatrix();
				}else if(n==3){
					camera.position.set(0,0,4);
					camera.updateProjectionMatrix();
				}else if(n==4){
					camera.position.set(0,0,-4);
					camera.updateProjectionMatrix();
				}else if(n==5){
					camera.position.set(-4,0,0);
					camera.updateProjectionMatrix();
				}else if(n==6){
					camera.position.set(4,0,0);
					camera.updateProjectionMatrix();
				}

			}
			function resizePanel(){
				panelWidth=window.innerWidth-o_width;
				panelHeight=o_height*(1-0.618);

				//panelR.setSize( window.innerWidth-o_width, o_height*(1-0.618));
				//position
				panelR.domElement.style.position = 'absolute';
				panelR.domElement.style.top= '0px';
				var str=o_width.toString();
				str+='px';
				panelR.domElement.style.left = str;
				//size
				panelCamera.aspect=panelWidth/panelHeight;
				panelCamera.updateProjectionMatrix();
				panelR.setSize( panelWidth, panelHeight);
				//panelCamera.aspect = 1;
				//panelCamera.updateProjectionMatrix();

			}
			function onWindowResize() {
				o_width=window.innerWidth*0.618;
			   	o_height=window.innerHeight;
				resizeButtons();
				resizePanel();

				camera.aspect = o_width/o_height;
				camera.updateProjectionMatrix();
				renderer.setSize( o_width, o_height);
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
				controls.update();
			}
			var hammerG,arm2G,arm1G,trunkG,baseG;
			var somem=new THREE.Matrix4();
			var arm1Step=1;
			var trunkStep=1;
			var arm2Step=1;
			somem.makeScale(0.1,0.1,0.1);
			function render() {
				if(!modelInitialized){
					if(base && trunk && arm1 && arm2 && hammer){
						hammerG=new THREE.Object3D();
						arm2G=new THREE.Object3D();
						arm1G=new THREE.Object3D();
						trunkG=new THREE.Object3D();
						baseG=new THREE.Object3D();
						hammerG.angle=0;
						arm2G.angle=0;
						arm1G.angle=0;
						trunkG.angle=0;


						hammerG.add(hammer);
						arm2G.add(hammerG);
						arm2G.add(arm2);
						arm1G.add(arm2G);
						arm1G.add(arm1);
						trunkG.add(arm1G);
						trunkG.add(trunk);
						baseG.add(trunkG);
						baseG.add(base);
						scene.add(baseG);

						modelInitialized=true;
					}
					else return;
				}
				scene.position.x=0
				scene.position.y=0
				scene.position.z=0
				camera.lookAt( scene.position );


				if(arm1Step>0 && arm1G.angle+arm1Step>90){
					arm1Step=-arm1Step;
				}
				else if(arm1Step<0 && arm1Step+arm1G.angle<0){
					arm1Step=-arm1Step;
				}
				if(arm2Step>0 && arm2G.angle+arm2Step>0){
					arm2Step=-arm2Step;
				}
				else if(arm2Step<0 && arm2Step+arm2G.angle<-120){
					arm2Step=-arm2Step;
				}

				//rotateArm1(arm1G.angle+arm1Step);
				//rotateArm2(arm2G.angle+arm2Step);
				//rotateTrunk(trunkG.angle+trunkStep);
				//balanceHammer();
				renderer.render( scene, camera );
				panelR.render(panelScene,panelCamera);
			}

			//Rotate Objects
			function rotateTrunk(angle){
				trunkG.angle=angle;
				var angle=trunkG.angle/180*Math.PI;
				trunkG.matrix.identity();
				var m=new THREE.Matrix4();
				m.rotateByAxis(trunk.axis, angle);
				trunkG.applyMatrix(m);
			}
			function rotateArm1(angle){
				arm1G.angle=angle;
				angle=arm1G.angle/180*Math.PI;
				arm1G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm1.pivot);
				m.rotateByAxis(arm1.axis, angle);
				m.translate(new THREE.Vector3(-1*arm1.pivot.x, -1*arm1.pivot.y,-1*arm1.pivot.z));
				arm1G.applyMatrix(m);
			}
			function rotateArm2(angle){
				arm2G.angle=angle;
				angle=arm2G.angle/180*Math.PI;
				arm2G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm2.pivot);
				m.rotateByAxis(arm2.axis, angle);
				m.translate(new THREE.Vector3(-1*arm2.pivot.x, -1*arm2.pivot.y,-1*arm2.pivot.z));
				arm2G.applyMatrix(m);
			}
			function rotateHammer(angle){
				hammerG.angle=angle;
				angle=hammerG.angle/180*Math.PI;
				hammerG.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(hammer.pivot);
				m.rotateByAxis(hammer.axis, angle);
				m.translate(new THREE.Vector3(-1*hammer.pivot.x, -1*hammer.pivot.y,-1*hammer.pivot.z));
				hammerG.applyMatrix(m);
			}
			function balanceHammer(){
				rotateHammer(arm1G.angle+arm2G.angle);
			}

			//Tackle Interactive
			renderer.domElement.addEventListener('mousedown', onMouseDown, false);
			function getGridPos(event){
				var eleLeft=renderer.domElement.offsetLeft;
				var eleTop=renderer.domElement.offsetTop;
				var eleX=(event.clientX-eleLeft)/o_width*2-1;
				var eleY=(event.clientY-eleTop)/o_height*(-2)+1;
				var vector = new THREE.Vector3(eleX,eleY,0.5 );
				projector.unprojectVector( vector, camera );
				var dir = vector.sub( camera.position ).normalize();
				var ray = new THREE.Ray( camera.position, dir );
				var distance = - camera.position.y / dir.y;
				var pos = camera.position.clone().add( dir.multiplyScalar( distance));
				return new THREE.Vector2(pos.x,pos.z);
			}

			function getPanelPos(event){
				var eleLeft=panelR.domElement.offsetLeft;
				var eleTop=panelR.domElement.offsetTop;
				var eleX=(event.clientX-eleLeft)/(window.innerWidth-o_width)*2-1;
				var eleY=(event.clientY-eleTop)/o_height(1-0.618)*(-2)+1;
				var vector = new THREE.Vector3(eleX,eleY,0.5 );
				projector.unprojectVector( vector, panelCamera );
				var dir = vector.sub( panelCamera.position ).normalize();
				var ray = new THREE.Ray( panelCamera.position, dir );
				var distance = - panelCamera.position.y / dir.y;
				var pos = panelCamera.position.clone().add( dir.multiplyScalar( distance));
				return new THREE.Vector2(pos.x,pos.z);
			}

			function onMouseDown(event){
				var pos=getGridPos(event);
				if(event.button==0){
						var i;
						for(i=0;i<pathCurve.points.length;i++){
							if(pos.distanceTo(pathCurve.points[i])<pathCurve.pointRadius){
								pathCurve.mouseDown=true;
								pathCurve.pointPos=i;
								console.log('mousedown at', i);
								break;
							}
						}
						//delete points
						if(pathCurve.deleteStatus&&pathCurve.mouseDown){
							pathCurve.points.splice(pathCurve.pointPos,1);
							pathCurve.draw(scene);
							pathCurve.mouseDown=false;
							pathCurve.pointPos=-1;
						}
				}
				//add point	
				if(event.button==2){
					if(pos.x>=-1 && pos.x<=1 && pos.y>=-1 && pos.y<=1 && pos.distanceTo(new THREE.Vector2(0,0)) > 0.3){
						pathCurve.points.push(new THREE.Vector2(pos.x,pos.y));
						pathCurve.draw(scene);
					}
				}
			}
			renderer.domElement.addEventListener('mousemove', onMouseMove, false);
			function onMouseMove(event){
				var pos=getGridPos(event);
				//move points
				if(pathCurve.mouseDown && pos.x>=-1 && pos.x<=1 && pos.y>=-1 && pos.y<=1 && pos.distanceTo(new THREE.Vector2(0,0)) > 0.3){
					controls.userRotate=0;
					pathCurve.points[pathCurve.pointPos].set(pos.x,pos.y);
					pathCurve.draw(scene);
					renderer.domElement.style.cursor="move";
				}
			}
			renderer.domElement.addEventListener('mouseup', onMouseUp, false);
			function onMouseUp(event){
				var pos=getGridPos(event);
				if(pathCurve.mouseDown){
					pathCurve.mouseDown=0;
					pathCurve.pointPos=-1;
					renderer.domElement.style.cursor="default";
				}
				controls.userRotate=1;
			}
		</script>
	</body>
</html>
