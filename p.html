<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Computer Animation Homework 2</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #e2d8ce;
				margin: 0px;
				overflow: hidden;
			}
			.btn{
				position:absolute;
				top:200px;
				left:800px;
				width:200px;
				padding:0px;
				margin:0px;
				background-color:#e2d8ce;
			}
			.btnImg{
				padding:0px;
				margin:0px;
			}
			#info{
				padding:0px;
				margin:0px;
				position:absolute;
			}


		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
		<script src="js/jquery.min.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/glMatrix.min.js"></script>
		<script src="js/curve.js"></script>
		<button class="btn" type="button" id="clear" onclick="clearPathCurvePoints()"/>
			<img class="btnImg" src="image/clear.png" id="clearImg"></img>
		</button>

		<button class="btn" type="button" id="delete" onclick="deletePathCurvePoints()"/>
			<img class="btnImg" src="image/delete.png" id="deleteImg"></img>
		</button>

		<button class="btn" type="button" id="playOrPause" onclick="playOrPause()"/>
			<img class="btnImg" src="image/play.png" id="playOrPauseImg"></img>
		</button>

		<button class="btn" type="button" id="stop" onclick="stop()"/>
			<img class="btnImg" src="image/stop.png" id="stopImg"></img>
		</button>

		<button class="btn" type="button" id="drop" onclick="dropSphere()"/>
			<img class="btnImg" src="image/drop.png" id="dropImg"></img>
		</button> 

		<button class="btn" type="button" id="view1" onclick="setView(1)"/>
			<img class="btnImg" src="image/view1.png" id="view1Img"></img>
		</button>

		<button class="btn" type="button" id="view2" onclick="setView(2)"/>
			<img class="btnImg" src="image/view2.png" id="view2Img"></img>
		</button>

		<button class="btn" type="button" id="view3" onclick="setView(3)"/>
			<img class="btnImg" src="image/view3.png" id="view3Img"></img>
		</button>

		<button class="btn" type="button" id="view4" onclick="setView(4)"/>
			<img class="btnImg" src="image/view4.png" id="view4Img"></img>
		</button>

		<button class="btn" type="button" id="view5" onclick="setView(5)"/>
			<img class="btnImg" src="image/view5.png" id="view5Img"></img>
		</button>

		<button class="btn" type="button" id="view6" onclick="setView(6)"/>
			<img class="btnImg" src="image/view6.png" id="view6Img"></img>
		</button> 


		
		<p id="info">

		<pre>
</pre>
		</p>
		<script>
			var loader, base, trunk, arm1, arm2, hammer, umbrella;
			var container, stats;
			var camera, scene, renderer, objects;
			var particleLight, pointLight;
			var modelInitialized=false;
			var projector=new THREE.Projector();
			var pathCurve=new Curve();
			var controls;
			var panelCurve=new Curve();
			var panelR,panelScene,panelCamera,panelWidth,panelHeight;
			var panelPointer,panelFloat;
			var timeT=0,timeStep=1/(60*5),prevTimeT;
			var player={};
			var pillarRadius=0.03;
			player.status="Stop";
			var ball,ballRadius=0.08,ballRotateX=0,ballRotateZ=0,ballPrevPos=new THREE.Vector3();
			var script=[];
			var pillarHeight=0.2;
			var pillars=[];
			var trunkHeight=0.176;
			var hammerHeight=0.176*0.76;
			var trunkRadius=0.13;
			var f;
			var spheres=[];
			var sphereRadius=0.05;
			var gridSize=2;
			var gravity=-0.008;

			var uBall;
			var uHeight=0.3;
			var uRadius=0.15;
			var uPrevPos=new THREE.Vector3();


			init();
			animate();
	
			function init() {
				container = document.createElement('div');
				document.body.appendChild(container);

				o_width=window.innerWidth*0.618;
				o_height=window.innerHeight;
				{
					camera = new THREE.PerspectiveCamera( 45, o_width / o_height, 0.025, 2000 );
					//camera = new THREE.OrthographicCamera(-1,1,1,-1);
					setView(1);
					window.addEventListener( 'resize', onWindowResize, false );
				}

				scene = new THREE.Scene();

				// Grid
				{
					var size = gridSize, step = 0.2;
					var geometry = new THREE.Geometry();
					for ( var i = - size; i <= size; i += step ) {
						geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );
						geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
						geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
					}
					var material = new THREE.LineBasicMaterial( { color: 0xb3aca4, opacity: 1, linewidth:1 } );
					var line = new THREE.Line( geometry, material );
					line.type = THREE.LinePieces;
					scene.add( line );
				}

				//model
				{
					scale=0.04;
					//var m=new THREE.Matrix4();
					//m.scale(scale);
					var m=new THREE.Matrix4();
					m.makeScale(scale,scale,scale);
					loader = new THREE.JSONLoader();
					loader.load( 'obj/robot/base.js', function ( geometry ) {
						base = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true  } ) );
						base.applyMatrix(m);
					} );
					loader.load( 'obj/robot/trunk.js', function ( geometry ) {
						trunk = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						trunk.pivot=new THREE.Vector3(0,0,0);
						trunk.axis=new THREE.Vector3(0,-1,0);
						trunk.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm1.js', function ( geometry ) {
						arm1 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm1.pivot=new THREE.Vector3(-0.13,0.176,0);
						arm1.axis=new THREE.Vector3(0,0,-1);
						arm1.applyMatrix(m);
					} );
					loader.load( 'obj/robot/arm2.js', function ( geometry ) {
						arm2 = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw: true } ) );
						arm2.pivot=new THREE.Vector3(-0.530,0.176,0);
						arm2.axis=new THREE.Vector3(0,0,1);
						arm2.applyMatrix(m);
					} );
					loader.load( 'obj/robot/hammer.js', function ( geometry ) {
						hammer = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw:true } ) );

						hammer.pivot=new THREE.Vector3(-0.914,0.176,0);
						hammer.axis=new THREE.Vector3(0,0,1);
						hammer.applyMatrix(m);
					} );
					loader.load( 'obj/robot/umbrella.js', function ( geometry ) {
						umbrella = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial( { overdraw:true } ) );

						umbrella.pivot=new THREE.Vector3(-0.914,0.176,0);
						umbrella.axis=new THREE.Vector3(0,0,1);
						umbrella.applyMatrix(m);
					} );

				}


				//renderer
				{
					//renderer = new THREE.CanvasRenderer();
					renderer = new THREE.WebGLRenderer();
					renderer.setSize( o_width, o_height);

					renderer.domElement.style.position = 'absolute';
					renderer.domElement.style.top= '0px';
					renderer.domElement.style.left = '0px';
					renderer.domElement.style.backgroundColor="#e8dfd6";
					container.appendChild( renderer.domElement );

					controls = new THREE.OrbitControls( camera , renderer.domElement);
					controls.addEventListener( 'change', render );
				}
				//panel
				{
					panelR=new THREE.CanvasRenderer();
					panelR = new THREE.WebGLRenderer();
					//background
					panelR.domElement.style.backgroundColor="#e8dfd6";


					//curve initial points
					panelCurve.points.push(new THREE.Vector2(0,0));
					panelCurve.points.push(new THREE.Vector2(0.3333,0.3333));
					panelCurve.points.push(new THREE.Vector2(0.6666,0.6666));
					panelCurve.points.push(new THREE.Vector2(1,1));


					panelWidth=(window.innerWidth-o_width);
					panelHeight=o_height*(1-0.618);
					panelScene=new THREE.Scene();		
					panelCamera = new THREE.PerspectiveCamera( 45, o_width / o_height, 0.025, 2000 );
					resizePanel();
					panelCurve.draw(panelScene);

					container.appendChild(panelR.domElement );
				}
				
				//panel coordinates
				{

					var geometry = new THREE.Geometry();
					geometry.vertices.push(new THREE.Vector3(-0.1,0,0));
					geometry.vertices.push(new THREE.Vector3(1.2,0,0));
					geometry.vertices.push(new THREE.Vector3(0,0,-0.1));
					geometry.vertices.push(new THREE.Vector3(0,0,1.1));
					var material = new THREE.LineBasicMaterial( { color: 0xb3aca4, opacity: 1, linewidth:1 } );
					var line = new THREE.Line( geometry, material );
					line.type=THREE.LinePieces;
					panelScene.add( line );
					

					panelPointer=new THREE.Object3D();	
					var sphere=new THREE.Mesh(new THREE.SphereGeometry(0.042, 24, 24 ),new THREE.MeshBasicMaterial( { color: 0x0173ad,overdraw:true } ));
					sphere.position.x=0
					sphere.position.y=0;
					sphere.position.z=0;
					panelPointer.add(sphere);

					geometry = new THREE.Geometry();
					geometry.vertices=[];
					geometry.vertices.push(new THREE.Vector3(0,0,0));
					geometry.vertices.push(new THREE.Vector3(0,0,0.1));
					material = new THREE.LineBasicMaterial( { color: 0x0173ad, opacity: 1, linewidth:1 } );
					line = new THREE.Line( geometry, material );
					panelPointer.add(line);
					panelScene.add(panelPointer);

					panelFloat=new THREE.Mesh(new THREE.SphereGeometry(0.038, 24, 24 ),new THREE.MeshBasicMaterial( { color: 0x0173ad,overdraw:true } ));
					panelFloat.position.x=0;
					panelFloat.position.y=0;
					panelFloat.position.z=0;

					panelScene.add(panelFloat);

				}
				//uball
				{
					var geometry = new THREE.SphereGeometry( uRadius, 30, 30 ); 
					var material = new THREE.MeshNormalMaterial( { overdraw:
						true  } );
					uBall = new THREE.Mesh( geometry, material ); 
					uBall.position.set(0,0,uHeight);
					//scene.add(uBall);
				}
				//ball
				{
					var earthTexture = new THREE.Texture();
					var eLoader = new THREE.ImageLoader();
	
					eLoader.addEventListener( 'load', function ( event ) {
						earthTexture.image = event.content;
						earthTexture.needsUpdate = true;
					} );


					eLoader.load( 'image/land_ocean_ice_cloud_512.jpg' ); 
					/*
					eLoader.load( 'image/land_ocean_ice_cloud_512.jpg' , 
					function ( event ) {
						earthTexture.image = event.content;
						earthTexture.needsUpdate = true;
					});
					*/

					var geometry = new THREE.SphereGeometry( ballRadius, 30, 30 );
					var material = new THREE.MeshBasicMaterial( { map: earthTexture, overdraw: true } );

					ball = new THREE.Mesh( geometry, material );
					resetBallPos();
					scene.add( ball );

				}

				//stats
				{
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					container.appendChild(stats.domElement);
				}

				//buttons
				resizeButtons();
				
				//remove pillars 
				//updatePillars();

				//script
				updateScript();

				
			}

			/* pillars: object for pillars 
			 * When clear/add/delete/move points, the updatePillars is called, geometry will rebuilt
			 */
			function updatePillars(){
				var i;
				for(i=0;i<pillars.length;i++){
					scene.remove(pillars[i]);
				}
				pillars=[];
				for(i=1;i<pathCurve.points.length;i++){
					var geometry=new THREE.CylinderGeometry(pillarRadius, pillarRadius, pillarHeight, 24, 24, false)
					var material=new THREE.MeshNormalMaterial( { overdraw: true  } ) ;
					var pillar = new THREE.Mesh( geometry, material);
					pillar.position.set(pathCurve.points[i].x,pillarHeight/2,pathCurve.points[i].y);

					pillars.push(pillar);
					scene.add(pillars[pillars.length-1]);
				}
			}
			function resetBallPos(){
				ball.position.set(-1,ballRadius,-1);
				ballPrevPos.set(-1,ballRadius,-1);
			}
			function resizeButtons(){
				var bWidth=(1-0.618)*window.innerWidth/6;
				var bHeight=bWidth;
				var imgWidth=bWidth-4;
				var imgHeight=imgWidth;
				$('.btn').css("width",bWidth);
				$('.btn').css("height",bHeight);
				$('.btnImg').css("width",imgWidth);
				$('.btnImg').css("height",imgHeight);
				var topB=o_height*(1-0.618);
				var leftB=o_width;

				$('#clear').css("top",topB+bHeight);
				$('#clear').css("left",leftB);

				$('#delete').css("top",topB+bHeight);
				$('#delete').css("left",leftB+bWidth*1);

				$('#playOrPause').css("top",topB+bHeight);
				$('#playOrPause').css("left",leftB+bWidth*2);

				$('#stop').css("top",topB+bHeight);
				$('#stop').css("left",leftB+bWidth*3);

				$('#drop').css("top",topB+bHeight);
				$('#drop').css("left",leftB+bWidth*4);
				//views
				$('#view1').css("top",topB);
				$('#view1').css("left",leftB+bWidth*0);

				$('#view2').css("top",topB);
				$('#view2').css("left",leftB+bWidth*1);

				$('#view3').css("top",topB);
				$('#view3').css("left",leftB+bWidth*2);

				$('#view4').css("top",topB);
				$('#view4').css("left",leftB+bWidth*3);

				$('#view5').css("top",topB);
				$('#view5').css("left",leftB+bWidth*4);

				$('#view6').css("top",topB);
				$('#view6').css("left",leftB+bWidth*5);

				$('#info').css("top",topB+2*bHeight);
				$('#info').css("left",leftB);

		
			}
			function clearPathCurvePoints(){
				pathCurve.points=[];
				pathCurve.draw(scene);
				resetBallPos();
				updateScript();
			}
			function deletePathCurvePoints(){
				if(pathCurve.deleteStatus==undefined || pathCurve.deleteStatus==0){
					pathCurve.deleteStatus=1;
					$('#deleteImg').attr("src", "image/deleteShadow.png");
				}else{
					pathCurve.deleteStatus=1-pathCurve.deleteStatus;
					$('#deleteImg').attr("src", "image/delete.png");
				}
			}
			function playOrPause(){
			}

			function setView(n){
				if(n==1){
					camera.position.set(-2,2,2);
					camera.updateProjectionMatrix();
				}else if(n==2){
					camera.position.set(0,4,0);
					camera.updateProjectionMatrix();
				}else if(n==3){
					camera.position.set(0,0,4);
					camera.updateProjectionMatrix();
				}else if(n==4){
					camera.position.set(0,0,-4);
					camera.updateProjectionMatrix();
				}else if(n==5){
					camera.position.set(-4,0,0);
					camera.updateProjectionMatrix();
				}else if(n==6){
					camera.position.set(4,0,0);
					camera.updateProjectionMatrix();
				}

			}
			function resizePanel(){
				panelWidth=(window.innerWidth-o_width);
				panelHeight=o_height*(1-0.618);

				//position
				panelR.domElement.style.position = 'absolute';
				panelR.domElement.style.top= '0px';
				var str=o_width.toString();
				str+='px';
				panelR.domElement.style.left = str;

				//size
				panelR.setSize( panelWidth, panelHeight);

				//camera
				panelCamera.position.set(0.5,-1.7,0.5);
				panelCamera.lookAt(new THREE.Vector3(0.5,0,0.5));
				panelCamera.updateProjectionMatrix();
				panelCamera.aspect=panelWidth/panelHeight;
				panelCamera.updateProjectionMatrix();
				panelCamera.rotation.set(1.5707963267948966,0,0);
				panelCamera.updateMatrix();

			}
			function onWindowResize() {
				o_width=window.innerWidth*0.618;
			   	o_height=window.innerHeight;
				resizeButtons();
				resizePanel();

				camera.aspect = o_width/o_height;
				camera.updateProjectionMatrix();
				renderer.setSize( o_width, o_height);
			}
			function animate() {
				requestAnimationFrame( animate );
				render();
				stats.update();
				controls.update();
			}
			var hammerG,arm2G,arm1G,trunkG,baseG;
			var somem=new THREE.Matrix4();
			var arm1Step=1;
			var trunkStep=1;
			var arm2Step=1;
			somem.makeScale(0.1,0.1,0.1);

			function render() {
				if(!modelInitialized){
					if(base && trunk && arm1 && arm2 && umbrella){
						umbrellaG=new THREE.Object3D();
						arm2G=new THREE.Object3D();
						arm1G=new THREE.Object3D();
						trunkG=new THREE.Object3D();
						baseG=new THREE.Object3D();
						umbrellaG.angle=0;
						arm2G.angle=0;
						arm1G.angle=0;
						trunkG.angle=0;


						umbrellaG.add(umbrella);
						arm2G.add(umbrellaG);
						arm2G.add(arm2);
						arm1G.add(arm2G);
						arm1G.add(arm1);
						trunkG.add(arm1G);
						trunkG.add(trunk);
						baseG.add(trunkG);
						baseG.add(base);
						scene.add(baseG);

						modelInitialized=true;
					}
					else return;
				}
				f=Math.round(timeT/timeStep);
				//rotate parts angle with the script says
				trunkScript();
				armScript();
				//set pillar height as script says
				//pillarScript();

				if(player.status=="Play"){
					prevTimeT=timeT;
					timeT+=timeStep;	
					if(timeT>1)timeT=0;
					updatePointer();
				}
				//update Ball position and rotation
				updateBall();
				//update curve X tics on panel
				updatePointer();
				updateSpheres();	
				renderer.render( scene, camera );
				panelR.render(panelScene,panelCamera);
			}

			function updateSpheres(){
				// bounary remove 
				Array.prototype.remove = function(from, to) {
				  var rest = this.slice((to || from) + 1 || this.length);
				  this.length = from < 0 ? this.length + from : from;
				  return this.push.apply(this, rest);
				};

				var rangeR=4;	
				for(var i=0;i<spheres.length;i++){
					r=spheres[i].position.x * spheres[i].position.x+
					spheres[i].position.y * spheres[i].position.y;
					if(r>rangeR*rangeR){
						scene.remove(spheres[i]);
						spheres.remove(i);	
					}
				}
				var rangeZ=8;
				for(var i=0;i<spheres.length;i++){
					if(spheres[i].position.z > rangeZ || spheres[i].position.z<-rangeZ)
					{
						scene.remove(spheres[i]);
						spheres.remove(i);
					}
				}



						

				//小球之间的碰撞
				var p=new THREE.Vector3();
				var p1=new THREE.Vector3();
				var p2=new THREE.Vector3();
				var l1=0,l2=0;
				var v=new THREE.Vector3();
				for(var i=0;i<spheres.length;i++){
					for(var j=i+1;j<spheres.length;j++){
						if
						(spheres[i].position.distanceTo(spheres[j].position)<2*sphereRadius)
						{
							if(spheres[j].hash in spheres[i].cSet){
								continue;
							}
							spheres[i].cSet[spheres[j].hash]=true;
							spheres[j].cSet[spheres[i].hash]=true;
							p.copy(spheres[i].position);
							p.sub(spheres[j].position);
							p.normalize();	

							p1.copy(p);
							l1=p1.dot(spheres[i].v);
							p1.multiplyScalar(l1);

							p2.copy(p);
							l2=p2.dot(spheres[j].v);
							p2.multiplyScalar(l2);

							spheres[i].v.sub(p1);
							spheres[i].v.add(p2);

							spheres[j].v.sub(p2);
							spheres[j].v.add(p1);

							
						}else{
							if(spheres[j].hash in spheres[i].cSet){
								delete spheres[i].cSet[spheres[j].hash];
								delete spheres[j].cSet[spheres[i].hash];
							}
						}
					}
				}
				//球和地球之间的碰撞
				for(var i=0;i<spheres.length;i++){
					if(spheres[i].position.distanceTo(ball.position)<sphereRadius+ballRadius){
						if(spheres[i].touchBall==false){
						spheres[i].touchBall=true;
						p.copy(spheres[i].position);
						p.sub(ball.position);
						p.normalize();
						p1.copy(spheres[i].v);
						var l1=p1.dot(p);
						p1.copy(p);
						p1.multiplyScalar(l1);

						v.copy(ball.position);
						v.sub(ballPrevPos);
						p2.copy(v);
						var l2=p2.dot(p);
						p2.copy(p);
						p2.multiplyScalar(l2);

						//sphere[i].v=spheres[i].v-2p1+p2
						spheres[i].v.add(p1.multiplyScalar(-2));
						spheres[i].v.add(p2);
						}

					}else{
						spheres[i].touchBall=false;
					}
				}

				//球与伞之间的碰撞
				p.copy(ball.position);	
				p.y=uHeight;
				uBall.position.copy(p);
				p1.copy(ballPrevPos);
				p1.y=uHeight;
				uPrevPos.copy(p1);

				for(var i=0;i<spheres.length;i++){
					if(spheres[i].position.distanceTo(uBall.position)<uRadius+sphereRadius){
						if(spheres[i].touchUmbrella){
							continue;
						}
						spheres[i].touchUmbrella=true;
						p.copy(spheres[i].position);
						p.sub(uBall.position);
						p.normalize();
						p1.copy(spheres[i].v);
						var l1=p1.dot(p);
						p1.copy(p);
						p1.multiplyScalar(l1);

						v.copy(uBall.position);
						v.sub(uPrevPos);
						p2.copy(v);
						var l2=p2.dot(p);
						p2.copy(p);
						p2.multiplyScalar(l2);

						//sphere[i].v=spheres[i].v-2p1+p2
						spheres[i].v.add(p1.multiplyScalar(-2));
						spheres[i].v.add(p2);

						//sphere[i].v=spheres[i].v-2p1+v-p2
					}else{
						spheres[i].touchUmbrella=false;
					}
				}

				//与地面的碰撞
				//ground	
				for(var i=0;i<spheres.length;i++){
					spheres[i].v.y+=gravity;
					if(spheres[i].position.x>-gridSize &&
					spheres[i].position.x<gridSize &&
					spheres[i].position.z>-gridSize &&
					spheres[i].position.z<gridSize){
						if (spheres[i].position.y<sphereRadius){
							//spheres[i].v.y-=gravity;
							spheres[i].v.y-=gravity;
							spheres[i].v.y=Math.abs(spheres[i].v.y*0.9);
						}
					}
				}
				//new position
				for(var i=0;i<spheres.length;i++){
					spheres[i].position.add(spheres[i].v);
				}
					
			}
			function trunkScript(){
				rotateTrunk(script[f].trunkAngle+Math.PI);
			}
			function armScript(){
				var h=script[f].height-trunkHeight+hammerHeight;
				//h=-1*trunkHeight+hammerHeight;
				var r=script[f].radius-trunkRadius;
				/*
				if(h>0.24){
					console.log("h>0.24");
				}
				*/
				var a1=0.4,a2=0.385;
				var done=false;
				var a,b;
				var t,minT=99999999;
				for(a=0;a<=Math.PI/2;a+=0.005){
					t=Math.pow((Math.sin(a)*a1-h),2)+Math.pow((r-Math.cos(a)*a1),2)-a2*a2;
					if(t>=-0.008 && t<=0.008){
						done=true;
						break;
					}
				}
				if(!done){
					script[f].able=false;
					/*
					console.log("cannot find a");
					console.log("Cannot reach radius=",script[f].radius,"height=",script[f].height);
					*/
					balanceUmbrella();
					return;
				}
				done=false;
				for(b=0;b<2.8*Math.PI/3.0;b+=0.005){
					k=a-b+Math.PI/2;
					t=Math.pow((r-Math.sin(k)*a2),2)+Math.pow((h+Math.cos(k)*a2),2)-a1*a1;
					if(t>=-0.008 && t<=0.008){
						done=true;
						break;
					}
				}
				if(!done){
					script[f].able=false;
					/*
					console.log("cannot find b");
					console.log("Cannot reach radius=",script[f].radius,"height=",script[f].height);
					*/
					balanceUmbrella();
					return;
				}
				rotateArm1(a);
				rotateArm2(b);
				balanceUmbrella();
			}
			/*
			function pillarScript(){
				if(f==0){
					updatePillars();
					return ;
				}
				for(i=0;i<pillars.length;i++){
					if(script[f-1].pillarHeight[i+1]!=script[f].pillarHeight[i+1]){
						scene.remove(pillars[i]);
						var geometry=new THREE.CylinderGeometry(pillarRadius, pillarRadius, script[f].pillarHeight[i+1], 24, 24, false)
						var material=new THREE.MeshNormalMaterial( { overdraw: true  } ) ;
						var pillar = new THREE.Mesh( geometry, material);
						pillar.position.set(pathCurve.points[i+1].x,script[f].pillarHeight[i+1]/2,pathCurve.points[i+1].y);

						pillars[i]=pillar;
						scene.add(pillars[i]);
	
					}
				}
			}
			*/
			function updateBall(){
				var percent=panelCurve.getPointX(timeT).y
				var pos=pathCurve.getPointAt(pathCurve.getLength()*percent);
				if(pos==0){
					return;	
				}
				//position
				ballPrevPos.x=ball.position.x;
				ballPrevPos.z=ball.position.z;
				ball.position.set(pos.x,ballRadius,pos.y);
				
				//rotation
				var dx=ball.position.x-ballPrevPos.x;
				var dz=ball.position.z-ballPrevPos.z;
				var dd=Math.sqrt(dx*dx+dz*dz);
				var du=dd/ballRadius;
				var dxu;
				var dzu;

				if(dz==0){
					dxu=0;
				}else{
					dxu=dd/ballRadius*dz/dd;
				}

				if(dx==0){
					dzu=0;
				}else{
					dzu=-1*dd/ballRadius*dx/dd;
				}

				ballRotateZ+=dzu;
				ballRotateX+=dxu;

				ball.rotation.set(ballRotateX,0,ballRotateZ);
				//ball.rotation.set(ballRotateX,0,0);
				//ball.rotation.set(0,0,ballRotateZ);
			}

			//Rotate Objects
			function rotateTrunk(angle){
				trunkG.angle=angle;
				trunkG.matrix.identity();
				var m=new THREE.Matrix4();
				m.rotateByAxis(trunk.axis, angle);
				trunkG.applyMatrix(m);
			}
			function rotateArm1(angle){
				arm1G.angle=angle;
				arm1G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm1.pivot);
				m.rotateByAxis(arm1.axis, angle);
				m.translate(new THREE.Vector3(-1*arm1.pivot.x, -1*arm1.pivot.y,-1*arm1.pivot.z));
				arm1G.applyMatrix(m);
			}
			function rotateArm2(angle){
				arm2G.angle=angle;
				arm2G.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(arm2.pivot);
				m.rotateByAxis(arm2.axis, angle);
				m.translate(new THREE.Vector3(-1*arm2.pivot.x, -1*arm2.pivot.y,-1*arm2.pivot.z));
				arm2G.applyMatrix(m);
			}
			function rotateHammer(angle){
				hammerG.angle=angle;
				hammerG.matrix.identity();
				var m=new THREE.Matrix4();
				m.translate(hammer.pivot);
				m.rotateByAxis(hammer.axis, angle);
				m.translate(new THREE.Vector3(-1*hammer.pivot.x, -1*hammer.pivot.y,-1*hammer.pivot.z));
				hammerG.applyMatrix(m);
			}
			function rotateUmbrella(angle){
				umbrellaG.angle=angle;
				umbrellaG.matrix.identity();
				var m=new THREE.Matrix4();

				m.translate(umbrella.pivot);
				m.rotateByAxis(umbrella.axis, angle);
				m.translate(new THREE.Vector3(-1*umbrella.pivot.x, -1*umbrella.pivot.y,-1*umbrella.pivot.z));

				umbrellaG.applyMatrix(m);
			}

			function balanceHammer(){
				rotateHammer(arm1G.angle-arm2G.angle);
			}

			function balanceUmbrella(){
				rotateUmbrella(arm1G.angle-arm2G.angle);
			}
			//Tackle Interactive
			renderer.domElement.addEventListener('mousedown', onMouseDown, false);
			function getGridPos(event){
				var eleLeft=renderer.domElement.offsetLeft;
				var eleTop=renderer.domElement.offsetTop;
				var eleX=(event.clientX-eleLeft)/o_width*2-1;
				var eleY=(event.clientY-eleTop)/o_height*(-2)+1;
				var vector = new THREE.Vector3(eleX,eleY,0.5 );
				projector.unprojectVector( vector, camera );
				var dir = vector.sub( camera.position ).normalize();
				var ray = new THREE.Ray( camera.position, dir );
				var distance = - camera.position.y / dir.y;
				var pos = camera.position.clone().add( dir.multiplyScalar( distance));
				return new THREE.Vector2(pos.x,pos.z);
			}
			function onMouseDown(event){
				var pos=getGridPos(event);
				if(event.button==0){
						var i;
						for(i=0;i<pathCurve.points.length;i++){
							if(pos.distanceTo(pathCurve.points[i])<pathCurve.pointRadius){
								pathCurve.mouseDown=true;
								pathCurve.pointPos=i;
								break;
							}
						}
						//delete points
						if(pathCurve.deleteStatus&&pathCurve.mouseDown){
							pathCurve.points.splice(pathCurve.pointPos,1);
							pathCurve.draw(scene);
							pathCurve.mouseDown=false;
							pathCurve.pointPos=-1;
							updateScript();
						}
				}
				//add point	
				if(event.button==2){
					if(pos.x>=-1 && pos.x<=1 && pos.y>=-1 && pos.y<=1 && pos.distanceTo(new THREE.Vector2(0,0)) > 0.3){
						pathCurve.points.push(new THREE.Vector2(pos.x,pos.y));
						pathCurve.draw(scene);
						updateScript();
					}
				}
			}
			renderer.domElement.addEventListener('mousemove', onMouseMove, false);
			function onMouseMove(event){
				var pos=getGridPos(event);
				//move points
				if(pathCurve.mouseDown && pos.x>=-1 && pos.x<=1 && pos.y>=-1 && pos.y<=1 && pos.distanceTo(new THREE.Vector2(0,0)) > 0.3){
					controls.userRotate=0;
					pathCurve.points[pathCurve.pointPos].set(pos.x,pos.y);
					pathCurve.draw(scene);
					renderer.domElement.style.cursor="move";
				}
			}
			renderer.domElement.addEventListener('mouseup', onMouseUp, false);
			function onMouseUp(event){
				var pos=getGridPos(event);
				if(pathCurve.mouseDown){
					pathCurve.mouseDown=0;
					pathCurve.pointPos=-1;
					renderer.domElement.style.cursor="default";
					//move point
					updateScript();
				}
				controls.userRotate=1;
			}




			function getPanelPos(event){
				var eleLeft=panelR.domElement.offsetLeft;
				var eleTop=panelR.domElement.offsetTop;
				var eleX=(event.clientX-eleLeft)/panelWidth*2-1;
				var eleY=(event.clientY-eleTop)/panelHeight*(-2)+1;
				var vector = new THREE.Vector3(eleX,eleY,0.5 );
				projector.unprojectVector( vector, panelCamera );
				var dir = vector.sub( panelCamera.position ).normalize();
				var ray = new THREE.Ray( panelCamera.position, dir );
				var distance = - panelCamera.position.y / dir.y;
				var pos = panelCamera.position.clone().add( dir.multiplyScalar( distance));
				return new THREE.Vector2(pos.x,pos.z);
			}

			panelR.domElement.addEventListener('mousedown', panelOnMouseDown, false);
			function panelOnMouseDown(event){
				var pos=getPanelPos(event);
				if(event.button==0){
						var i;
						for(i=1;i<panelCurve.points.length-1;i++){
							if(pos.distanceTo(panelCurve.points[i])<panelCurve.pointRadius){
								panelCurve.mouseDown=true;
								panelCurve.pointPos=i;
								return ;
								break;
							}
						}
						if(pos.distanceTo(panelPointer.position)<panelCurve.pointRadius){
							panelPointer.mouseDown=true;
							return ;
						}
				}
			}

			panelR.domElement.addEventListener('mousemove', panelOnMouseMove, false);
			function panelOnMouseMove(event){
				var pos=getPanelPos(event);
				if(panelCurve.mouseDown){
					panelR.domElement.style.cursor="move";
					var posBack=panelCurve.points[panelCurve.pointPos].clone();
					panelCurve.points[panelCurve.pointPos].set(pos.x,pos.y);
					var border=panelCurve.getBorder();
					if(panelCurve.isXAsc() && border.top<=1 && border.bottom>=0){
						panelCurve.draw(panelScene);
						updatePointer();
					}else{
						panelCurve.points[panelCurve.pointPos]=posBack;
						panelCurve.draw(panelScene);
					}
				}else if(panelPointer.mouseDown && pos.x>=0 && pos.x<=1){
					timeT=pos.x;
					updatePointer();
				}
			}
			function updatePointer(){
				panelPointer.position.x=timeT;
				panelFloat.position.set(timeT,0, panelCurve.getPointX(timeT).y);
			}

			panelR.domElement.addEventListener('mouseup', panelOnMouseUp, false);
			function panelOnMouseUp(event){
				var pos=getPanelPos(event);
				if(panelCurve.mouseDown){
					panelCurve.mouseDown=0;
					panelCurve.pointPos=-1;
					panelR.domElement.style.cursor="default";
					//move speed curve
					updateScript();
				}else if(panelPointer.mouseDown){
					panelPointer.mouseDown=0;
				}
			}

			function playOrPause(){
				if(player.status=="Stop" || player.status=="Pause"){
					player.status="Play";
					$('#playOrPauseImg').attr("src","image/pause.png");
				}else if(player.status=="Play"){
					$('#playOrPauseImg').attr("src","image/play.png");
					player.status="Pause";
				}
			}
			function stop(){
				player.status="Stop";
				timeT=0;
				ballRotateX=0;
				ballRotateZ=0;
				$('#playOrPauseImg').attr("src","image/play.png");
			}
			/* update script, called when init, clear/add/delete/move points, move speed curve 
			 * Still need it under all mentioned senarios, but the action need be changed.
			 */
			function updateScript(){
				console.log("updateScript");
				var pathLength=pathCurve.getLength();
				var t;
				script=[];
				for(t=0;t<=1;t+=timeStep){
					script.push({
						trunkAngle:0,
						radius:0.6,
						height:2*ballRadius+0.01,
						able:true,
					});
				}
				//少于两个点退出
				if(pathCurve.points.length<2){
					return ;
				}
				var zero=new THREE.Vector2();
				var percent,pos,angle;
				for(t=0;t<=1;t+=timeStep){
					percent=panelCurve.getPointX(t).y
					pos=pathCurve.getPointAt(pathCurve.getLength()*percent);
					angle=Math.acos(pos.x/pos.distanceTo(zero));
					if(pos.y<0){angle*=-1};
					script[Math.round(t/timeStep)].trunkAngle=angle;
					script[Math.round(t/timeStep)].radius=pos.distanceTo(zero);
				}
				//多于两个点初始化
				/*
				var rotateList=getRotateList();
				for(t=0;t<=1;t+=timeStep){
					script[Math.round(t/timeStep)].trunkAngle=rotateList[0];
					script[Math.round(t/timeStep)].radius=pathCurve.points[0].length();
					script[Math.round(t/timeStep)].height=pillarHeight;
					script[Math.round(t/timeStep)].able=true;
					

					//### delete to clear pillarHeight data in frames.
					for(j=0;j<pathCurve.points.length;j++){
						script[Math.round(t/timeStep)].pillarHeight.push(pillarHeight);
					}

				}

				pathCurve.tList=[];
				pathCurve.tList.push(0);
				var i;
				for(i=1;i<pathCurve.points.length;i++){
					pathCurve.tList.push(999999);
				}
				var tPercent,pos;
				var hammerRadius=0.05; 
				for(t=0;t<=1;t+=timeStep){
					//得到时刻t，球在path上的percent
					tPercent=panelCurve.getPointX(t).y;
					//通过percent，得到球在path上的位置
					pos=pathCurve.getPointAt(pathLength*tPercent);
					for(i=1;i<pathCurve.points.length;i++){
						d=pos.distanceTo(pathCurve.points[i]);
						//如果该时球的位置和某个柱子的位置很近，那么该时刻柱子必须被砸下去, 柱子不能和球，也不能和锤子碰撞
						if(d<ballRadius+Math.max(pillarRadius,hammerRadius)){
							pathCurve.tList[i]=Math.min(pathCurve.tList[i],t);
						}
					}
				}
				
				//console.log("tList",pathCurve.tList);


				pathCurve.pillars=[];
				pathCurve.pillars.push({
					pushedDown:true,
					height:0,
				});
				for(i=1;i<pathCurve.points.length;i++){
					pathCurve.pillars.push({
						pushedDown:false,
						height:pillarHeight,
					});
				}
					
				var currentT=0;
				var currentAngle=rotateList[0];
				var currentHeight=script[0].height;
				var currentRadius=script[0].radius;
				var l=pathCurve.points.length;
				var pillars=pathCurve.pillars
				var tList=pathCurve.tList;
				var points=pathCurve.points;
				var minTime;
				var target;
				var pillarsLeft=l-1;
				var oldTarget=0;
				var timeSave=0;
				var t=timeStep,f;
				var oldTime=0;
				var oldHeight=script[0].height;
				var i;
				while(pillarsLeft>0){
					minTime=999999;
					for(i=1;i<l;i++){
						//如果已经被连带砸下了,那么就跳过这个柱子，去找下一个急需被砸下的。
						if(!pillars[i].pushedDown && minTime>tList[i]){
								minTime=tList[i];
								target=i;
						}
					}
					var pCovered=[];
					for(i=1;i<l;i++){
						if(!pillars[i].pushedDown && points[i].distanceTo(points[target])<pillarRadius+hammerRadius){
							pCovered.push(i);	
						}
					}
					//console.log("oldTarget",oldTarget,"target",target);
					var angle=getRotate(rotateList[oldTarget],rotateList[target]);
					var dtime=(tList[target]-oldTime);
					var moveTime=dtime*0.5;
					var downTime=dtime*0.3;
					var angleSpeed=angle/moveTime;
					//console.log("angle", angle,"dtime",dtime,"moveTime",moveTime,"downTime",downTime,"angleSpeed",angleSpeed);
					//如果速度太慢，则修正为一个较快的速度.
					if(Math.abs(angleSpeed)<3){
						angleSpeed=angleSpeed/Math.abs(angleSpeed)*3;
						moveTime=angle/angleSpeed;
					}
					//如果下压的时间太长，则修正为一个快的下压速度。
					
					if(downTime>0.08)downTime=0.08;
					//console.log("angle", angle,"dtime",dtime,"moveTime",moveTime,"downTime",downTime,"angleSpeed",angleSpeed);


					//move stage
					var oldf=Math.round((oldTime)/timeStep);
					var newf=Math.round((oldTime+moveTime)/timeStep);
					var f;
					//console.log(oldTime,moveTime,newf);
					script[newf].height=pillarHeight;
					script[newf].radius=points[target].length();
					script[newf].trunkAngle=rotateList[oldTarget]+angle;
					
					for(f=oldf+1;f<newf;f++){
						script[f].height=oldHeight+(pillarHeight+0.05-oldHeight)*(f-oldf)/(newf-oldf);
						script[f].radius=script[oldf].radius+(script[newf].radius-script[oldf].radius)*(f-oldf)/(newf-oldf);
						script[f].trunkAngle=rotateList[oldTarget]+angle*(f-oldf)/(newf-oldf);
						//console.log("angle/(newf-oldf)",angle/(newf-oldf),"(newf-oldf)",newf-oldf,"angle",angle,"newf",newf,"oldf",oldf);
					}
					for(f=oldf;f<=newf;f++){
						f=Math.max(1,f);
						for(j=0;j<l;j++){
							script[f].pillarHeight[j]=script[f-1].pillarHeight[j];
						}
					}
					//down stage
					oldf=newf;
					newf=Math.round((oldTime+moveTime+downTime)/timeStep);
					script[newf].height=0;
					script[newf].radius=script[oldf].radius;
					script[newf].trunkAngle=script[oldf].trunkAngle;
					for(f=oldf;f<=newf;f++){
						f=Math.max(1,f);
						for(j=0;j<l;j++){
							script[f].pillarHeight[j]=script[f-1].pillarHeight[j];
						}
					}

					for(f=oldf+1;f<newf;f++){
						script[f].height=script[oldf].height-(pillarHeight+0.05)*(f-oldf)/(newf-oldf);	
						script[f].radius=script[oldf].radius;
						script[f].trunkAngle=script[oldf].trunkAngle;
						for(i=0;i<pCovered.length;i++){
							script[f].pillarHeight[pCovered[i]]=Math.max(0,Math.min(pillarHeight,script[f].height));
							
						}
					}

					oldTime=oldTime+moveTime+downTime;
					oldTarget=target;
					oldHeight=0;

					for(i=0;i<pCovered.length;i++){
						pillars[pCovered[i]].pushedDown=true;
					}
					pillarsLeft-=pCovered.length;
				}
				//round to origin
				//up
				upTime=0.08;
				if(upTime>(1-oldTime)*0.5){
					upTime=(1-oldTime)*0.5;
				}

				var oldf=Math.round((oldTime)/timeStep);
				var newf=Math.round((oldTime+upTime)/timeStep);

				script[newf].height=pillarHeight;
				script[newf].radius=script[oldf].radius;
				script[newf].trunkAngle=script[oldf].trunkAngle;
				for(f=oldf;f<=newf;f++){
					f=Math.max(1,f);
					for(j=0;j<l;j++){
						script[f].pillarHeight[j]=script[f-1].pillarHeight[j];
					}
				}

				for(f=oldf+1;f<newf;f++){
					script[f].height=pillarHeight*(f-oldf)/(newf-oldf);	
					script[f].radius=script[oldf].radius;
					script[f].trunkAngle=script[oldf].trunkAngle;
				}
				oldHeight=pillarHeight;

				//move
				target=0;
				angle=getRotate(rotateList[oldTarget],rotateList[target]);
				moveTime=1-oldTime-upTime;
				var angleSpeed=angle/moveTime;
				//如果速度太慢，则修正为一个较快的速度.
				if(Math.abs(angleSpeed)<3){
					angleSpeed=angleSpeed/Math.abs(angleSpeed)*3;
					moveTime=angle/angleSpeed;
				}

				var newf=Math.round((oldTime+upTime+moveTime)/timeStep);
				oldf=Math.round((oldTime+upTime)/timeStep);
				script[newf].height=pillarHeight;
				script[newf].radius=points[target].length();
				script[newf].trunkAngle=rotateList[oldf]+angle;
				for(f=oldf;f<=newf;f++){
					f=Math.max(1,f);
					for(j=0;j<l;j++){
						script[f].pillarHeight[j]=script[f-1].pillarHeight[j];
					}
				}

				for(f=oldf+1;f<newf;f++){
					script[f].height=oldHeight+(pillarHeight-oldHeight)*(f-oldf)/(newf-oldf);
					script[f].radius=script[oldf].radius+(script[newf].radius-script[oldf].radius)*(f-oldf)/(newf-oldf);
					script[f].trunkAngle=rotateList[oldTarget]+angle*(f-oldf)/(newf-oldf);
					//console.log("angle/(newf-oldf)",angle/(newf-oldf),"(newf-oldf)",newf-oldf,"angle",angle,"newf",newf,"oldf",oldf);
				}

				//updatePillars();	
				*/
				return ;
			}
			function getRotate(a1,a2){
				var da=Math.abs(a2-a1);
				var t;
				da=Math.min(da,2*Math.PI-da);
				t=a1+da-a2;
				if(t>=-0.01 && t<=0.01) return da;
				t=a1+da-a2-2*Math.PI;
				if(t>=-0.01 && t<=0.01) return da;
				t=a1+da-a2+2*Math.PI;
				if(t>=-0.01 && t<=0.01) return da;
				t=a1-da-a2;
				if(t>=-0.01 && t<=0.01) return -da;
				t=a1-da-a2-2*Math.PI;
				if(t>=-0.01 && t<=0.01) return -da;
				t=a1-da-a2+2*Math.PI;
				if(t>=-0.01 && t<=0.01) return -da;
				console.log("a1",a1,"a2",a2,"da",da);
			}
			function getRotateList(){
				//current angle=0
				//for each point in curve , add the angle.
				var vertices=pathCurve.points;
				if(vertices.length<2)return 0;
				var a1,a2;
				var zero=new THREE.Vector2();
				var rotateList=[];
				for(i=0;i<vertices.length;i++){
					a2=Math.acos(vertices[i].x/vertices[i].distanceTo(zero));
					if(vertices[i].y<0){
						a2*=-1;
					}
					rotateList.push(a2);
				}
				return rotateList;
			}

			function dropSphere(){
				var h=0.8;
				var v = new THREE.Vector3();
				var geometry = new THREE.SphereGeometry( sphereRadius, 30, 30 ); 
				var material = new THREE.MeshNormalMaterial( { overdraw:
					true  } );
				//v.x=(script[f].radius-ballRadius+0.05)*Math.cos(script[f].trunkAngle);
				//v.z=(script[f].radius-ballRadius+0.05)*Math.sin(script[f].trunkAngle);
				v.copy(ball.position);
				v.y=h;

				var N=10;
				var sparse=30;
				for(var i=0;i<N;i++){
					for(var j=0;j<N;j++){
						var sphere = new THREE.Mesh( geometry, material ); 
						sphere.position.set(v.x-N/2*sphereRadius+2*sphereRadius*i,h,v.z-N/2*sphereRadius+2*sphereRadius*j);
						sphere.v=new
						THREE.Vector3(0,0,0);
						sphere.hash=Math.random().toString(36).substring(7);
						sphere.cSet={};
						spheres.push(sphere);
						scene.add(spheres[spheres.length-1]);
					}
				}
				/*
				for(var i=0;i<N;i++){
					var sphere = new THREE.Mesh( geometry, material ); 
					sphere.position.set(v.x+(Math.random()-0.5)/100,h+i*sphereRadius*2.2,v.z+(Math.random()-0.5)/100);
					//sphere.position.set(v.x,h,v.z);
					sphere.v=new
					THREE.Vector3((Math.random()-0.5)/sparse,(Math.random()-0.5)/200-0.05,(Math.random()-0.5)/sparse);
					//THREE.Vector3(0,(Math.random()-0.5)/200-0.05,0);
					//THREE.Vector3(0,-0.08,0);
					sphere.hash=Math.random().toString(36).substring(7);
					sphere.cSet={};
					spheres.push(sphere);

					scene.add(spheres[spheres.length-1]);
				}
				*/
			}
		</script>
	</body>
</html>
